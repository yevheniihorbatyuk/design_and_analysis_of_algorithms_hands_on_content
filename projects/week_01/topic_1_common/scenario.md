# Підсумкова таблиця алгоритмів "Розділяй і володарюй"

## Порівняльна таблиця всіх розглянутих алгоритмів

| № | Алгоритм "Розділяй і володарюй" | Складність D&C | Альтернативний алгоритм | Складність альтернативи | Покращення | Практичне застосування |
|---|---|---|---|---|---|---|
| 1 | **Merge Sort** | O(n log n) | Insertion Sort | O(n²) | ~50x для n=10K | Стабільне сортування, зовнішнє сортування |
| 2 | **Quick Sort** | O(n log n) середнє | Bubble Sort | O(n²) | ~100x для n=10K | Швидке сортування в пам'яті |
| 3 | **Binary Search** | O(log n) | Linear Search | O(n) | ~1000x для n=1M | Пошук у відсортованих масивах |
| 4 | **Karatsuba Multiplication** | O(n^1.585) | Traditional Multiply | O(n²) | ~10x для 1000 цифр | Криптографія, великі числа |
| 5 | **Strassen Matrix** | O(n^2.81) | Classical Matrix | O(n³) | ~2x для 1024×1024 | Наукові обчислення, ШІ |
| 6 | **FFT** | O(n log n) | DFT | O(n²) | ~100x для n=1K | Обробка сигналів, зображень |
| 7 | **Quick Select** | O(n) середнє | Sort & Select | O(n log n) | ~10-20x для n=100K | Статистика, медіани |
| 8 | **Closest Pair** | O(n log n) | Brute Force | O(n²) | ~100x для n=10K | Комп'ютерна геометрія, ГІС |

## Детальний аналіз кожного алгоритму

### 1. Merge Sort (Сортування злиттям)
```
Принцип: Розділяй масив → Сортуй частини → Зливай результати
Рекурентне рівняння: T(n) = 2T(n/2) + O(n)
Переваги: Стабільний, передбачуваний час, підходить для зовнішнього сортування
Недоліки: Потребує O(n) додаткової пам'яті
```

### 2. Quick Sort (Швидке сортування)
```
Принцип: Вибери pivot → Розділи масив → Сортуй частини
Рекурентне рівняння: T(n) = 2T(n/2) + O(n) (середній випадок)
Переваги: Сортування "на місці", відмінна локальність пам'яті
Недоліки: O(n²) у гіршому випадку, нестабільний
```

### 3. Binary Search (Бінарний пошук)
```
Принцип: Порівняй з серединою → Вибери половину → Повтори
Рекурентне рівняння: T(n) = T(n/2) + O(1)
Переваги: Логарифмічна складність, мінімальні витрати пам'яті
Недоліки: Потребує відсортованого масиву
```

### 4. Karatsuba Multiplication (Множення Карацуби)
```
Принцип: Розділи числа → 3 рекурсивні множення → Комбінуй результати
Рекурентне рівняння: T(n) = 3T(n/2) + O(n)
Переваги: Суттєве прискорення для великих чисел
Недоліки: Складність реалізації, константи накладних витрат
```

### 5. Strassen Matrix Multiplication (Множення матриць Штрассена)
```
Принцип: Розділи матриці 2×2 → 7 рекурсивних множень → Комбінуй
Рекурентне рівняння: T(n) = 7T(n/2) + O(n²)
Переваги: Кращий за кубічний алгоритм для великих матриць
Недоліки: Складна реалізація, великі константи, погана стабільність
```

### 6. Fast Fourier Transform (Швидке перетворення Фур'є)
```
Принцип: Розділи на чет/нечет → Рекурсивний FFT → Операції "метелика"
Рекурентне рівняння: T(n) = 2T(n/2) + O(n)
Переваги: Революція в обробці сигналів, широке застосування
Недоліки: Працює з числами у формі 2^k, складні числа
```

### 7. Quick Select (Швидкий вибір)
```
Принцип: Як Quick Sort, але рекурсія тільки в одну сторону
Рекурентне рівняння: T(n) = T(n/2) + O(n) (середній випадок)
Переваги: Лінійна складність, економія пам'яті
Недоліки: O(n²) у гіршому випадку, нестабільний відбір
```

### 8. Closest Pair of Points (Найближча пара точок)
```
Принцип: Розділи по x → Знайди в частинах → Перевір смугу
Рекурентне рівняння: T(n) = 2T(n/2) + O(n log n)
Переваги: Ефективний для великих наборів точок
Недоліки: Складна реалізація, потребує попереднього сортування
```

## Практичні поради по використанню

### Коли використовувати кожен алгоритм:

| Алгоритм | Найкраще використовувати коли | Уникати коли |
|----------|-------------------------------|--------------|
| **Merge Sort** | Потрібна стабільність, великі дані, гарантований час | Обмежена пам'ять |
| **Quick Sort** | Швидкість важливіша за стабільність, сортування в пам'яті | Потрібен гарантований час |
| **Binary Search** | Часті пошуки у відсортованих даних | Рідкі пошуки, несортовані дані |
| **Karatsuba** | Множення чисел >1000 цифр | Малі числа (<100 цифр) |
| **Strassen** | Матриці >1000×1000, наукові обчислення | Матриці <100×100, точність критична |
| **FFT** | Обробка сигналів, згортки, великі дані | Малі розміри, не степінь 2 |
| **Quick Select** | Пошук k-статистик, медіан | Потрібна стабільність вибору |
| **Closest Pair** | Геометричні задачі, >1000 точок | <100 точок, непланарні метрики |

## Аналіз Master Theorem

Для рекурентних рівнянь виду T(n) = aT(n/b) + f(n):

| Алгоритм | a | b | f(n) | Випадок MT | Результат |
|----------|---|---|------|------------|-----------|
| Merge Sort | 2 | 2 | O(n) | Case 2 | Θ(n log n) |
| Binary Search | 1 | 2 | O(1) | Case 3 | Θ(log n) |
| Karatsuba | 3 | 2 | O(n) | Case 1 | Θ(n^log₂3) |
| Strassen | 7 | 2 | O(n²) | Case 1 | Θ(n^log₂7) |
| FFT | 2 | 2 | O(n) | Case 2 | Θ(n log n) |

## Оптимізації та модифікації

### Гібридні підходи:
- **Introsort**: Quick Sort + Heap Sort для гарантування O(n log n)
- **Timsort**: Merge Sort + Insertion Sort для реальних даних
- **Quick Select + Median-of-Medians**: Гарантований O(n)

### Паралелізація:
- Merge Sort: Паралельне злиття
- Quick Sort: Паралельне розділення
- FFT: Паралельні "метелики"
- Matrix: Паралельні підматриці

## Висновки

Стратегія "розділяй і володарюй" дає:
- **Оптимальну або близьку до оптимальної складність** для багатьох задач
- **Елегантні та зрозумілі** рішення
- **Природну паралелізацію** алгоритмів
- **Математично красиві** рекурентні структури

Основна ідея: **розкладання складної задачі на простіші однотипні підзадачі з подальшим об'єднанням результатів**.

Це один з найпотужніших підходів в алгоритміці, що дозволяє досягати вражаючих результатів у продуктивності!